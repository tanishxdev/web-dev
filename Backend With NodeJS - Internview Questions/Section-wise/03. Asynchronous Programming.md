# Asynchronous Programming

---

# **20. What are callbacks in Node.js?**

## **Concept**

A **callback** in Node.js is a function passed **as an argument** to another function, and executed **after** an asynchronous operation completes.

Node.js uses callbacks heavily because:

* JavaScript runs on a **single thread**
* Node must not block the thread
* I/O operations (file, DB, API) must run **asynchronously**

Callbacks allow Node.js to stay **non-blocking** and **event-driven**.

---

# **Why Callbacks Exist in Node.js**

Node.js needs to do things like:

* read a file
* query a database
* make an HTTP request
* compress a file
* read user input

But these are **slow operations**.

Instead of stopping everything and waiting, Node:

1. Starts the operation
2. Registers a callback
3. Moves on immediately
4. Executes the callback when results are ready

This is the foundation of async programming in Node.js.

---

# **Basic Callback Example**

```js
function greet(name, callback) {
  console.log("Hello", name);
  callback();
}

greet("Tanish", () => {
  console.log("Callback executed");
});
```

---

# **Callback with Asynchronous Code**

```js
const fs = require("fs");

fs.readFile("data.txt", "utf-8", (err, data) => {
  if (err) throw err;
  console.log(data);         // Runs after file is read
});

console.log("Reading file...");  // Runs first
```

Why?
File reading is asynchronous.

---

# **Error-First Callback Pattern (Important for Interviews)**

Most Node.js async functions follow:

```js
function callback(err, result) {}
```

Example:

```js
fs.readFile("file.txt", "utf-8", (err, data) => {
  if (err) {
    console.log("Error occurred");
    return;
  }
  console.log(data);
});
```

This is called the **error-first callback pattern**.

---

# **Callback Flow (How Node Executes Them)**

1. Asynchronous function is called
2. Node offloads work to thread pool
3. Once complete → callback added to event loop queue
4. Event loop executes callback

---

# **Callbacks Are Used In**

* File system (fs module)
* HTTP request/response
* Database queries
* Streams
* Events
* Timers (`setTimeout`, `setInterval`)

---

# **Callback Hell (Preview for Next Topic)**

Nested callbacks look like this:

```js
doA(() => {
  doB(() => {
    doC(() => {
      doD(() => {
        console.log("Done");
      });
    });
  });
});
```

This leads to:

* unreadable code
* hard debugging
* deeply nested structure

Promises and async/await were introduced to solve this.

---

# **Short Interview Answer**

A callback in Node.js is a function passed as an argument to another function and executed after an asynchronous operation completes. Node uses callbacks to implement its non-blocking I/O model, allowing operations like file reading and network requests to run without blocking the main thread.

---

# **Summary Table**

| Concept  | Explanation                             |
| -------- | --------------------------------------- |
| Callback | Function executed after async operation |
| Why used | Non-blocking, async behavior            |
| Pattern  | Error-first: `(err, result)`            |
| Problems | Callback hell                           |

---

# **21. What is callback hell and how can it be avoided?**

## **Concept**

**Callback Hell** (also called “Pyramid of Doom”) occurs when multiple asynchronous operations are nested inside each other, creating deeply indented, unreadable, unmaintainable code.

This typically happens when:

* one async task depends on another
* developers chain many callbacks
* code becomes a pyramid shape

Example of callback hell:

```js
doA(() => {
  doB(() => {
    doC(() => {
      doD(() => {
        console.log("Done");
      });
    });
  });
});
```

This code is:

* hard to read
* hard to debug
* hard to maintain
* error handling becomes messy

---

# **Why Callback Hell Happens**

### 1. Node.js uses async functions heavily

### 2. Many operations depend on results from previous ones

### 3. Early Node.js versions lacked Promises and async/await

---

# **Real Example: Callback Hell in File Operations**

```js
const fs = require("fs");

fs.readFile("a.txt", "utf-8", (err, dataA) => {
  fs.readFile("b.txt", "utf-8", (err, dataB) => {
    fs.readFile("c.txt", "utf-8", (err, dataC) => {
      console.log(dataA, dataB, dataC);
    });
  });
});
```

---

# **How to Avoid Callback Hell**

Node.js offers **three main solutions**:

---

# **1. Use Named Functions**

Instead of nesting functions inline, separate them.

```js
function readA(err, dataA) {
  fs.readFile("b.txt", "utf-8", readB);
}

function readB(err, dataB) {
  fs.readFile("c.txt", "utf-8", readC);
}

function readC(err, dataC) {
  console.log("Done");
}

fs.readFile("a.txt", "utf-8", readA);
```

Reduces nesting, but still complex.

---

# **2. Use Promises (Much Cleaner)**

Promises flatten the structure.

```js
readFile("a.txt")
  .then(dataA => readFile("b.txt"))
  .then(dataB => readFile("c.txt"))
  .then(dataC => console.log("Done"))
  .catch(err => console.log(err));
```

No nesting.

---

# **3. Use async/await (Best Approach)**

Most modern Node.js code uses this.

```js
async function readFiles() {
  try {
    const a = await fs.promises.readFile("a.txt", "utf-8");
    const b = await fs.promises.readFile("b.txt", "utf-8");
    const c = await fs.promises.readFile("c.txt", "utf-8");
    console.log(a, b, c);
  } catch (err) {
    console.log(err);
  }
}

readFiles();
```

**async/await solves callback hell completely**.

---

# **4. Use Control Flow Libraries (older Node.js)**

Libraries like:

* async.js
* bluebird

Used before async/await became standard.

---

# **Short Interview Answer**

Callback hell happens when asynchronous callbacks are nested deeply, making code difficult to read and maintain. It can be avoided by using named functions, Promises, async/await, or control-flow libraries like async.js. Modern Node.js primarily uses Promises and async/await to solve callback hell.

---

# **Summary Table**

| Solution        | Description                  |
| --------------- | ---------------------------- |
| Named functions | Reduce nesting               |
| Promises        | Flatten async flow           |
| async/await     | Cleanest, most readable      |
| Libraries       | Older alternative (async.js) |

---

# **22. Explain promises in Node.js**

## **Concept**

A **Promise** in Node.js is an object that represents the **result of an asynchronous operation**.
It can be in one of three states:

1. **pending** – operation not finished
2. **fulfilled** – operation completed successfully
3. **rejected** – operation failed

Promises solve the problem of **callback hell** by providing a cleaner, chainable way to handle async logic.

---

# **Why Promises Are Needed**

Callbacks cause problems like:

* deep nesting
* unreadable code
* complicated error handling
* difficult sequencing

Promises fix these by:

* returning an object that represents the async result
* supporting `.then()` chaining
* unified `.catch()` error handling
* avoiding nested structures

---

# **Basic Promise Example**

```js
const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Task completed");
  }, 1000);
});

myPromise.then(result => {
  console.log(result);
});
```

Output after 1 second:

```
Task completed
```

---

# **States of a Promise**

| State     | Meaning          |
| --------- | ---------------- |
| pending   | Not completed    |
| fulfilled | resolve() called |
| rejected  | reject() called  |

---

# **Promise Chaining (Important)**

```js
doTaskA()
  .then(resultA => doTaskB())
  .then(resultB => doTaskC())
  .then(resultC => console.log("All tasks done"))
  .catch(err => console.log(err));
```

Clean, flat async flow.

---

# **Converting Callback Function to Promise**

Node.js provides promise versions via `fs.promises`:

```js
const fs = require("fs").promises;

fs.readFile("data.txt", "utf-8")
  .then(data => console.log(data))
  .catch(err => console.log(err));
```

---

# **Promise.all (Run tasks in parallel)**

```js
Promise.all([
  fs.readFile("a.txt", "utf-8"),
  fs.readFile("b.txt", "utf-8"),
  fs.readFile("c.txt", "utf-8"),
]).then(values => console.log(values));
```

Best for running independent async tasks simultaneously.

---

# **Promise.race (First settled Promise)**

```js
Promise.race([
  fetchData(),
  timeout(),
]);
```

Useful for timeouts and fallbacks.

---

# **Promise.any (First fulfilled Promise)**

Used when you only care about *success*, not failure.

---

# **Promises + async/await**

Promises are the foundation of async/await.

Example:

```js
async function run() {
  try {
    const result = await myPromise;
    console.log(result);
  } catch (err) {
    console.log(err);
  }
}
```

---

# **Why Promises Are Better Than Callbacks**

| Concept        | Callbacks      | Promises           |
| -------------- | -------------- | ------------------ |
| Structure      | Nested         | Flat               |
| Error Handling | Repeated       | Centralized        |
| Readability    | Hard           | Clean              |
| Sequencing     | Complicated    | Easy with chaining |
| Async Flow     | Hard to manage | Predictable        |

---

# **Short Interview Answer**

Promises in Node.js provide a cleaner way to handle asynchronous operations. They represent a future value and allow chaining using `.then()` and `.catch()`. Promises solve callback hell and are the foundation of async/await, enabling readable and maintainable asynchronous code.

---

# **Summary Table**

| Feature    | Explanation                            |
| ---------- | -------------------------------------- |
| States     | pending, fulfilled, rejected           |
| Methods    | then, catch, finally                   |
| Advantages | avoid callback hell, easier sequencing |
| Use Cases  | fs, DB calls, HTTP calls               |

---

# **23. How do async/await functions work in Node.js?**

## **Concept**

`async` and `await` are modern JavaScript features built on top of **Promises**, providing a cleaner, more synchronous-looking way to write asynchronous code.

They help solve:

* callback hell
* messy promise chaining
* difficult error handling

Async/await makes asynchronous code look like synchronous code.

---

# **Definition**

### **async function**

A function declared with `async` automatically returns a **Promise**.

### **await**

Pauses the execution of the async function until the Promise is fulfilled/rejected.

---

# **Basic Example**

```js
async function greet() {
  return "Hello";
}

greet().then(console.log);
```

Output:

```
Hello
```

Even though `"Hello"` is returned directly, async converts it into a Promise.

---

# **Example: Using await**

```js
function delay() {
  return new Promise(resolve => {
    setTimeout(() => resolve("Done"), 1000);
  });
}

async function run() {
  console.log("Start");
  const result = await delay();
  console.log(result);
  console.log("End");
}

run();
```

Output:

```
Start
Done
End
```

Execution **pauses** at await until the Promise resolves.

---

# **Async/Await with fs.promises**

```js
const fs = require("fs").promises;

async function readFileData() {
  try {
    const data = await fs.readFile("data.txt", "utf-8");
    console.log(data);
  } catch (err) {
    console.log(err);
  }
}

readFileData();
```

Cleaner than `.then().catch()`.

---

# **Error Handling (Very Important)**

Async/await allows simple try/catch:

```js
async function run() {
  try {
    const res = await fetchData();
    console.log(res);
  } catch (err) {
    console.log("Error:", err);
  }
}
```

Much easier than promise error chains.

---

# **Running Async Tasks in Parallel (Common Mistake)**

Wrong:

```js
const a = await taskA();
const b = await taskB();
```

Runs sequentially.

Correct:

```js
const [a, b] = await Promise.all([taskA(), taskB()]);
```

Both run in parallel.

---

# **Rules of async/await**

1. `await` only works inside `async` functions
2. async functions always return a Promise
3. await pauses only the current async function (not the whole thread)
4. You can mix await with Promise.all for concurrency

---

# **Async/Await vs Promises vs Callbacks**

| Feature        | Callbacks | Promises | Async/Await               |
| -------------- | --------- | -------- | ------------------------- |
| Readability    | Hard      | Medium   | Best                      |
| Error Handling | Messy     | Good     | Excellent                 |
| Async Flow     | Nested    | Chained  | Sequential like sync code |
| Debugging      | Difficult | Easier   | Easiest                   |

---

# **Real-World Example: Reading multiple files**

```js
const fs = require("fs").promises;

async function run() {
  const a = await fs.readFile("a.txt", "utf-8");
  const b = await fs.readFile("b.txt", "utf-8");
  console.log(a, b);
}

run();
```

---

# **Short Interview Answer**

Async/await is syntax built on top of Promises that provides a synchronous-looking way to write asynchronous code. An async function returns a Promise, and await pauses execution until the Promise resolves. It simplifies error handling using try/catch and eliminates callback hell.

---

# **Summary Table**

| Keyword     | Meaning                                 |
| ----------- | --------------------------------------- |
| async       | Makes function return a Promise         |
| await       | Pauses execution until Promise resolves |
| try/catch   | Handles errors cleanly                  |
| Promise.all | Enables parallel execution              |

---

# **24. What is the difference between synchronous and asynchronous methods in the fs module?**

## **Concept**

The **fs (File System)** module in Node.js provides two types of methods:

1. **Asynchronous (Non-blocking)** → Preferred for servers
2. **Synchronous (Blocking)** → Used rarely, mostly for scripts or initialization

Understanding the difference is essential because it directly affects **Node.js performance, scalability, and event loop behavior**.

---

# **1. Asynchronous FS Methods (Non-blocking)**

Examples:

* `fs.readFile()`
* `fs.writeFile()`
* `fs.appendFile()`
* `fs.unlink()`

These methods:

* offload the I/O operation to the **libuv thread pool**
* **do not block** the main thread
* execute a **callback** when the operation completes

### Example (Async):

```js
const fs = require("fs");

console.log("Start");

fs.readFile("data.txt", "utf-8", (err, data) => {
  console.log("File read complete");
});

console.log("End");
```

### Output:

```
Start
End
File read complete
```

Because the read happens **in the background**.

---

# **2. Synchronous FS Methods (Blocking)**

Examples:

* `fs.readFileSync()`
* `fs.writeFileSync()`
* `fs.appendFileSync()`
* `fs.unlinkSync()`

These methods:

* **block the event loop**
* nothing else runs until the operation is complete
* slow down servers if used inside request handlers

### Example (Sync):

```js
const fs = require("fs");

console.log("Start");

const data = fs.readFileSync("data.txt", "utf-8");
console.log("File read complete");

console.log("End");
```

### Output:

```
Start
File read complete
End
```

Everything waits for file read → **thread blocked**.

---

# **Performance Difference**

| Aspect       | Async FS                  | Sync FS                |
| ------------ | ------------------------- | ---------------------- |
| Event loop   | Not blocked               | Blocked                |
| Performance  | Fast                      | Slow                   |
| Scalability  | High                      | Low                    |
| Use case     | Servers, APIs             | Initialization scripts |
| Thread usage | Moves work to thread pool | Uses main thread       |

---

# **When to Use Async Methods**

### Ideal for:

* servers handling multiple requests
* reading logs or config files during runtime
* streaming large files
* any real-time system

---

# **When to Use Sync Methods**

### Acceptable for:

* startup configuration
* small CLI scripts
* one-time file read before server starts
* test scripts

Never use in a request handler.

---

# **Large File Example (Async using Streams)**

```js
const fs = require("fs");

const stream = fs.createReadStream("large.txt");
stream.on("data", chunk => console.log("Chunk received"));
```

Best for memory efficiency.

---

# **Short Interview Answer**

The fs module provides synchronous (blocking) and asynchronous (non-blocking) methods.
Asynchronous methods offload I/O tasks to the thread pool and allow Node.js to keep handling other work, making them ideal for servers. Synchronous methods block the event loop until completed and should only be used when performance is not critical, such as during initialization.

---

# **Summary Table**

| Method Type  | Example             | Blocking? | Use Case          |
| ------------ | ------------------- | --------- | ----------------- |
| Asynchronous | `fs.readFile()`     | No        | Server operations |
| Synchronous  | `fs.readFileSync()` | Yes       | Startup scripts   |

## Why thousands of requests don’t overload threads?
---
```md
* Node.js is single-threaded
* Heavy I/O is offloaded to libuv thread-pool
* libuv has **only 4 threads** by default
* So, can Node.js only handle **4 async tasks at a time**?
* But in real life, apps handle thousands of users and requests. How is that possible?

---

# **1. Very Important: MOST async tasks DO NOT use the thread pool**

### Only some operations use thread pool:

Examples that use libuv threads:

* `fs.readFile()`
* `crypto.pbkdf2()`
* some `zlib` operations
* some DNS lookups

But the **majority** of async operations DO NOT use thread pool.

---

## **2. Network operations DO NOT use thread pool**

This is the key point.

Network operations (like HTTP requests, database calls) rely on the **underlying OS kernel**, not the thread pool.

Examples:

* incoming HTTP requests
* outgoing HTTP requests
* MySQL queries
* MongoDB queries
* Redis commands
* TCP sockets
* HTTP(S) module

These are handled using:

* epoll (Linux)
* kqueue (macOS)
* IOCP (Windows)

These systems can handle **tens of thousands of open connections** without a thread per connection.

### **Meaning:**

Node.js can handle thousands of network operations at the same time **without using threads**.

---

# **3. Then what is the limit of libuv’s 4 threads?**

Only CPU-heavy or file-system-heavy tasks use those 4 threads.

Examples:

### Uses thread pool:

* reading/writing files
* compression
* encryption/hash
* some DNS resolving

### Does NOT use thread pool:

* HTTP servers
* database queries
* REST API calls
* message queues
* Redis/Mongo connections

So, **thread pool bottleneck only matters if your app does heavy FS or crypto tasks**.

---

# **4. Can we increase the libuv thread pool size?**

Yes. Many applications do this.

```bash
export UV_THREADPOOL_SIZE=64
```

or in code:

```js
process.env.UV_THREADPOOL_SIZE = 64;
```

Node.js allows up to **128 threads**.

So your 4-thread limitation is adjustable.

---

# **5. Real-life flow: why thousands of requests don’t overload threads**

Example:

1000 clients send HTTP requests.

Node.js handles this like:


Event Loop → handles connections (NOT thread pool)
Kernel → manages network events
Thread Pool → used only when needed


So even **10,000+ HTTP requests** don’t require the thread pool.

They only need:

* event loop
* OS kernel’s async capabilities

Thread pool is used only for operations that cannot be async inside OS.

---

# **6. Why Node.js scales so well?**

### Because:

Node.js **does NOT create a thread per request**.

Traditional servers like Java/PHP:

1000 requests = 1000 threads

Node.js:

1000 requests = 1 thread + kernel async I/O

That’s the secret.

---

# **7. Full Picture Summary**

| Task Type        | Uses Thread Pool? | Can Node.js handle 10000? |
| ---------------- | ----------------- | ------------------------- |
| HTTP requests    | No                | Yes                       |
| Database queries | No                | Yes                       |
| Redis/Mongo I/O  | No                | Yes                       |
| File read/write  | Yes               | Limited by pool           |
| Crypto hashing   | Yes               | Limited by pool           |
| Compression      | Yes               | Limited by pool           |

---

# **8. Real-life architecture to scale even more**

If app does heavy work:

### Solutions:

* Increase thread pool size
* Use Worker Threads
* Use clustering
* Move heavy tasks to queues (RabbitMQ, BullMQ)
* Use microservices

---

# **Final Simple Explanation**

Node.js can handle thousands of concurrent operations because:

### **1. Network operations don’t use thread pool**

They use OS async I/O (epoll/kqueue).

### **2. Thread pool is only for CPU or FS tasks**

And it can be increased beyond 4.

### **3. Event loop + OS kernel handles most of the load**

Not threads.
```
# **25. How does Node.js handle HTTP requests and responses?**

## **Concept**

Node.js handles HTTP requests and responses using the **built-in http module**, which follows an **event-driven, non-blocking architecture**.

When a request arrives:

1. Node emits a **"request"** event
2. Your server callback receives two objects:

   * `req` → Request object
   * `res` → Response object
3. You read request details from `req`
4. You send response back using `res`

Node.js processes all requests on a **single thread** but efficiently handles async tasks using its event loop.

---

# **Important Components**

### **1. http.createServer()**

Creates an HTTP server.

### **2. Request Object (req)**

Contains incoming request details:

* URL
* method (GET, POST, PUT…)
* headers
* body (for POST/PUT)

### **3. Response Object (res)**

Used to send data back to the client:

* status codes
* headers
* JSON/text responses

---

# **Basic Example: Handling HTTP Requests**

```js
const http = require("http");

const server = http.createServer((req, res) => {
  res.writeHead(200, { "Content-Type": "text/plain" });
  res.end("Hello from Node.js server");
});

server.listen(3000);
```

---

# **Handling Different Routes**

```js
const server = http.createServer((req, res) => {
  if (req.url === "/") {
    res.end("Home Page");
  } 
  else if (req.url === "/about") {
    res.end("About Page");
  } 
  else {
    res.writeHead(404);
    res.end("Not Found");
  }
});
```

---

# **Handling JSON Responses**

```js
const server = http.createServer((req, res) => {
  res.writeHead(200, { "Content-Type": "application/json" });

  res.end(JSON.stringify({
    message: "Hello API",
    status: "success"
  }));
});
```

---

# **Handling POST Request Body**

Node.js by default **does not parse JSON** from POST body.
We manually read the data chunks.

```js
const server = http.createServer((req, res) => {
  if (req.method === "POST") {
    let body = "";

    req.on("data", chunk => {
      body += chunk;
    });

    req.on("end", () => {
      const data = JSON.parse(body);
      res.end("Received: " + data.name);
    });
  }
});
```

---

# **Event-Driven Request Handling**

Internally:

1. Client sends request
2. Node emits `"request"` event
3. Your callback handles the request
4. Async tasks go to event loop/thread pool
5. Response is sent when ready

No thread is blocked.

---

# **Why Node Is Good at HTTP Handling**

### **1. Non-blocking I/O**

Multiple requests → handled concurrently.

### **2. Lightweight**

No thread-per-request model.

### **3. Event-driven**

Handles streaming, sockets, real-time traffic efficiently.

### **4. Perfect for JSON APIs**

JavaScript on both front-end and back-end.

---

# **Short Interview Answer**

Node.js handles HTTP requests using the built-in http module. When a request arrives, a “request” event triggers a callback with `req` (request) and `res` (response) objects. Developers use `req` to read the incoming data and `res` to send responses. All operations run in a non-blocking, event-driven manner, allowing Node.js to handle many concurrent requests efficiently.

---

# **Summary Table**

| Component    | Description                        |
| ------------ | ---------------------------------- |
| req          | Holds request data                 |
| res          | Used to send response              |
| createServer | Creates server                     |
| writeHead    | Set status + headers               |
| end          | Finish response                    |
| Event loop   | Handles connections asynchronously |

---
