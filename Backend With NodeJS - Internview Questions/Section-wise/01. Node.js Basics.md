# Basics 

---
# **1. What is Node.js and why is it used?**

## **Concept**

Node.js is a **JavaScript runtime environment** that allows developers to run JavaScript code **outside the browser**, typically on the server side.

It is built on **Google’s V8 engine**, and uses a **non-blocking, event-driven architecture**, which makes it highly suitable for:

* real-time applications
* scalable network servers
* data-intensive apps

---

## **Why Node.js Exists**

Before Node.js, JavaScript was only used in the browser.
But modern web applications needed:

* a single language for both frontend + backend
* high performance
* scalable servers
* handling thousands of concurrent requests

Node.js solved this by introducing **JavaScript on the server with an async model**.

---

## **Key Properties**

| Feature          | Explanation                                      |
| ---------------- | ------------------------------------------------ |
| Built on V8      | Very fast JavaScript execution                   |
| Single-threaded  | Uses one main thread for user code               |
| Event-driven     | Everything is triggered by events                |
| Non-blocking I/O | No waiting for slow tasks such as DB or file I/O |
| Scalable         | Handles many connections with low resources      |

---

## **Why Node.js is Used (Practical Reasons)**

### 1. **High performance**

Non-blocking I/O + V8 engine → very fast.

### 2. **Scalable for real-time apps**

Such as chat apps, live notifications, game servers.

### 3. **Single language stack (JavaScript everywhere)**

Front-end + Back-end in JS → faster development, lower mental load.

### 4. **Large ecosystem (npm)**

Over 2 million packages.

### 5. **JSON-native**

Perfect for REST APIs and microservices.

---

## **Example: Simple HTTP Server**

```js
// server.js

const http = require("http");

// Create a server using Node.js
const server = http.createServer((req, res) => {
  res.writeHead(200, { "Content-Type": "text/plain" });
  res.end("Hello from Node.js server");
});

// Port listening
server.listen(3000, () => {
  console.log("Server running on http://localhost:3000");
});
```

**Point:** One thread can handle thousands of requests.

---

## **Short Interview Answer**

Node.js is a JavaScript runtime built on Chrome's V8 engine. It allows JavaScript to run on the server. It uses an event-driven, non-blocking I/O model, which makes it lightweight, efficient, and ideal for building scalable network applications like APIs, microservices, and real-time applications.

---

## **Summary Table**

| Aspect           | Explanation                                       |
| ---------------- | ------------------------------------------------- |
| What is Node.js? | JavaScript runtime environment                    |
| Engine used      | Google V8                                         |
| Architecture     | Event-driven, non-blocking I/O                    |
| Why used?        | Speed, scalability, JS everywhere, real-time apps |
| Ideal for        | APIs, microservices, chat apps, streaming apps    |

---

# **2. How does Node.js handle child threads?**

## **Concept**

Node.js is often described as **single-threaded**, but this refers only to the thread that executes **JavaScript code**.

Internally, Node.js uses:

1. **Main Thread (Event Loop thread)** – runs your JS code
2. **Thread Pool (libuv)** – handles heavy/slow operations
3. **Child Threads** – created using `child_process` or Worker Threads

So Node.js is **single-threaded for JavaScript**, but **multi-threaded underneath**.

---

## **How Node.js Actually Uses Threads**

### **1. Event Loop (Main JS Thread)**

Runs your JavaScript logic.

### **2. libuv Thread Pool (4 threads by default)**

Used for heavy or blocking tasks:

* filesystem operations
* crypto operations
* DNS lookups
* compression

### **3. Child Processes (Manual Thread Creation)**

You can explicitly create extra threads in Node via:

* `child_process.fork()` – separate Node process
* `child_process.spawn()` – raw OS process
* `worker_threads` – true multi-threading inside the same process

---

## **Breakdown: How Child Threads Are Handled**

### **A. Using Thread Pool (automatic)**

Node uses a pool of background threads for tasks that cannot be non-blocking.

Example: fs.readFile(), hashing, compression.

Developers do not manage these threads manually.

---

### **B. Using child_process Module (manual)**

You can create actual OS-level processes.

```js
const { fork } = require("child_process");

const child = fork("./child.js");

child.on("message", (msg) => {
  console.log("Message from child:", msg);
});

child.send({ task: "start" });
```

**What happens:**

* A new Node.js process is created
* Communication happens via messaging
* Best used for CPU-heavy tasks

---

### **C. Using Worker Threads (manual)**

Worker Threads allow multi-threading *inside* a single Node.js process.

```js
// main.js
const { Worker } = require("worker_threads");

const worker = new Worker("./worker.js");

worker.on("message", (msg) => console.log("From Worker:", msg));
worker.postMessage("start");
```

Inside worker.js:

```js
const { parentPort } = require("worker_threads");

parentPort.on("message", () => {
  parentPort.postMessage("Worker completed task");
});
```

This is ideal for:

* CPU-intensive loops
* image processing
* encryption
* ML operations

---

## **Why Node Needs Child Threads**

Because the main JS thread must **never block**.

Blocking = server cannot handle more requests = very bad.

Heavy CPU tasks are moved to:

* libuv thread pool
* worker threads
* child processes

---

## **Short Interview Answer**

Node.js runs JavaScript on a single thread (event loop), but internally uses a libuv thread pool for heavy tasks. It can also create additional threads manually using `child_process` or `worker_threads`. This allows Node.js to remain non-blocking and scalable while still being able to perform CPU-intensive operations.

---

## **Summary Table**

| Technique         | Type                 | When to Use                        |
| ----------------- | -------------------- | ---------------------------------- |
| libuv Thread Pool | Automatic threads    | File I/O, crypto, compression      |
| child_process     | Separate OS process  | Heavy computation, parallel tasks  |
| worker_threads    | Real multi-threading | CPU-heavy work inside same process |
| Event Loop        | Main JS thread       | All application logic              |

---
# **3. Describe event-driven programming in Node.js**

## **Concept**

Event-driven programming is a programming model where **the flow of the application is determined by events**.

An **event** is anything that happens:

* a request arrives
* a timer finishes
* a file is read
* a user triggers an action
* data becomes available

Node.js uses this model heavily. Instead of waiting for operations to finish, Node registers **callbacks/listeners**, and when an event occurs, Node triggers the corresponding callback.

This architecture is the reason Node.js can handle **thousands of concurrent requests** efficiently.

---

## **Why Node.js Uses Event-Driven Programming**

1. **Non-blocking behaviour**
   No task blocks the main thread. Work happens asynchronously.

2. **High scalability**
   Perfect for network apps receiving many events (requests).

3. **Lightweight**
   No need to create a thread per request like traditional servers.

---

## **How Event-Driven Architecture Works Internally**

Node.js uses:

### **1. Event Loop**

Runs forever and listens for new events.

### **2. EventEmitter**

A core class that allows you to emit and listen to events.

### **3. Callbacks / Handlers**

Functions called when an event occurs.

### **4. Non-blocking APIs**

Like fs, http, timers, streams.

---

## **Real Example: EventEmitter**

```js
const EventEmitter = require("events");

// Create emitter instance
const emitter = new EventEmitter();

// Listener
emitter.on("greet", (name) => {
  console.log("Hello", name);
});

// Emit event
emitter.emit("greet", "Tanish");
```

**Explanation:**

* `emitter.on()` registers an event listener
* `emitter.emit()` triggers the event
* Node runs the callback asynchronously when the event occurs

---

## **Real Example: HTTP Server (Event-driven)**

```js
const http = require("http");

const server = http.createServer((req, res) => {
  res.end("Request received");
});

// "request" event is emitted each time someone hits the server
server.on("request", () => {
  console.log("A new request arrived");
});

server.listen(3000);
```

Every incoming request triggers a **request event**.

---

## **Why This Matters in An Interview**

Event-driven architecture is the heart of Node.js.

If you understand this, you understand:

* event loop
* async operations
* callbacks
* promises
* streams
* microtask vs macrotask

---

## **Short Interview Answer**

Node.js uses an event-driven programming model where actions are triggered by events instead of sequential execution. The Event Loop listens for events, and when they occur, the registered callback functions are executed. This allows Node.js to handle many concurrent operations without blocking the main thread, making it highly efficient for I/O-heavy and real-time applications.

---

## **Summary Table**

| Component         | Purpose                                        |
| ----------------- | ---------------------------------------------- |
| EventEmitter      | Create and handle custom events                |
| Event Loop        | Continuously listens and dispatches events     |
| Callbacks         | Functions executed when an event happens       |
| Non-blocking APIs | Allow async operations without blocking thread |

---

# **4. What is the Event Loop in Node.js?**

## **Concept**

The **Event Loop** is the core mechanism in Node.js that allows it to perform **non-blocking, asynchronous operations** even though JavaScript itself runs on a **single thread**.

It continuously checks:

1. Are there any events?
2. Are there pending callbacks?
3. Are there timers ready to run?
4. Are there promises resolved?

The Event Loop decides **what to run next**, ensuring Node.js remains fast and scalable.

---

## **Why the Event Loop Exists**

Node.js needs to:

* handle thousands of connections
* perform I/O without blocking
* stay responsive
* not use multiple threads for each request

The Event Loop makes this possible by moving heavy tasks to underlying systems (libuv, OS), and executing callbacks when results are ready.

---

## **High-Level Flow of the Event Loop**

Node’s Event Loop runs in **phases**, each handling specific types of operations.

### **Phases of the Event Loop**

1. **Timers**
   Executes callbacks scheduled by `setTimeout()` and `setInterval()`.

2. **Pending Callbacks**
   Runs I/O callbacks deferred from previous cycle.

3. **Idle / Prepare**
   Internal use.

4. **Poll**
   The heart of Node.js:

   * waits for new I/O events
   * executes I/O callbacks
   * if nothing to do → waits

5. **Check**
   Executes callbacks from `setImmediate()`.

6. **Close Callbacks**
   Handles cleanups like `socket.on("close")`.

### **Microtask Queue (Runs between phases)**

Includes:

* Promises (`.then`, `catch`)
* `process.nextTick()`

They run **before** moving to next phase.

---

## **Simple Example: Order of Execution**

```js
console.log("A");

setTimeout(() => console.log("B"), 0);

Promise.resolve().then(() => console.log("C"));

console.log("D");
```

### **Output**

```
A
D
C
B
```

### **Explanation**

1. A → sync
2. D → sync
3. C → microtask
4. B → next event loop cycle → timers phase

---

## **Visual Summary (Interview Friendly)**

JavaScript Thread
→ Executes your synchronous code

Event Loop
→ Manages timing, I/O, callbacks

libuv Thread Pool
→ Handles expensive tasks behind the scenes

Together → **non-blocking performance**.

---

## **Real Example of Event Loop + FS I/O**

```js
const fs = require("fs");

console.log("Start");

fs.readFile("data.txt", "utf-8", () => {
  console.log("File read complete");
});

console.log("End");
```

### **Output**

```
Start
End
File read complete
```

**Why?**
Reading file is asynchronous → goes to thread pool → callback scheduled → Event Loop prints after sync code.

---

## **Short Interview Answer**

The Event Loop is the mechanism that allows Node.js to perform non-blocking asynchronous operations on a single thread. It continuously checks for pending callbacks, timers, I/O events, promises, and other tasks, executing them in specific phases. This architecture enables Node.js to handle many concurrent operations efficiently.

---

## **Summary Table**

| Component         | Role                                         |
| ----------------- | -------------------------------------------- |
| Event Loop        | Executes async callbacks in phases           |
| Microtask Queue   | Runs promises and nextTick before each phase |
| libuv Thread Pool | Handles heavy tasks (fs, crypto, DNS)        |
| Single Thread     | Runs JS code                                 |

---


# **5. What is the difference between Node.js and traditional web server technologies?**

## **Concept**

Traditional web servers like **Apache**, **Nginx**, **Java Spring**, **PHP**, or **Ruby on Rails** follow a **multi-threaded, blocking model**.

Node.js, on the other hand, uses a **single-threaded, event-driven, non-blocking model**.

This fundamental architectural difference changes:

* how requests are handled
* how scalability works
* how resources are used
* what type of applications each is best for

---

## **High-Level Difference**

| Feature        | Node.js                         | Traditional Servers (Apache / Java / PHP)  |
| -------------- | ------------------------------- | ------------------------------------------ |
| Architecture   | Single-threaded, event-driven   | Multi-threaded / process-per-request       |
| I/O Model      | Non-blocking, async             | Blocking or thread-based                   |
| Concurrency    | Uses event loop                 | Uses multiple threads                      |
| Performance    | Excellent for I/O-heavy apps    | Good for CPU-heavy, but heavy thread usage |
| Resource Usage | Very low                        | Higher memory per thread                   |
| Use Cases      | Real-time apps, APIs, streaming | Monolithic apps, CPU-heavy apps            |

---

## **How Requests Are Handled**

### **Node.js Approach (Event-driven)**

```
1 thread handles:
→ All requests 
→ All events 
→ All callbacks
```

If an operation takes time (file read/database), it is offloaded to background workers. The main thread stays free.

This means:

* no waiting
* no blocking
* high concurrency

### **Traditional Server Approach (Thread per request)**

```
Each request = new thread
Thread waits until DB/file completes
```

Problems:

* thousands of threads = heavy memory
* blocking causes slowdowns
* context switching overhead

---

## **Example: Node.js Non-blocking**

```js
const fs = require("fs");

fs.readFile("data.txt", "utf-8", () => {
  console.log("Read complete");
});

console.log("Next task executed immediately");
```

Node moves the file read to thread pool; main thread continues.

---

## **Example: Traditional Blocking**

```php
<?php
$data = file_get_contents("data.txt");   // blocks
echo "This runs only after file read";
?>
```

PHP thread waits until file read completes.

---

## **Where Node.js Wins**

### 1. **Real-time Applications**

Examples:

* chats
* stock tickers
* collaborative tools
* live notifications

### 2. **API Servers**

Fast JSON processing + async I/O.

### 3. **Microservices**

Lightweight, fast, scalable.

### 4. **Streaming Apps**

Video/audio streaming.

---

## **Where Traditional Servers Win**

### 1. Heavy CPU computations

Such as:

* image processing
* ML computations
* data crunching

Node can do these using worker threads, but it's not natural.

### 2. Enterprise monolithic applications

Java/Spring is often preferred.

---

## **Short Interview Answer**

Traditional servers use a blocking, multi-threaded model where each request gets its own thread, which consumes memory and can block during I/O. Node.js uses a single-threaded, event-driven, non-blocking model, allowing it to handle many concurrent requests efficiently with minimal resources. This makes Node.js ideal for I/O-heavy, real-time applications.

---

## **Summary Table**

| Aspect         | Node.js                       | Traditional Web Servers          |
| -------------- | ----------------------------- | -------------------------------- |
| Threads        | Single thread + event loop    | One thread/process per request   |
| I/O            | Non-blocking                  | Blocking                         |
| Scalability    | Very high                     | Moderate                         |
| Performance    | Best for I/O tasks            | Best for CPU tasks               |
| Resource Usage | Low                           | High                             |
| Uses           | APIs, microservices, realtime | Large enterprise, CPU-heavy apps |

---

# **6. Explain what “non-blocking” means in Node.js**

## **Concept**

“Non-blocking” in Node.js means:

**Node does not wait for slow operations (like file read, database query, network request).
It starts the operation, registers a callback, and moves on to execute the next task.**

When the operation finishes, the callback is executed through the **Event Loop**.

This ensures **high concurrency** even with a single thread.

---

## **Blocking vs Non-Blocking**

### **Blocking (Synchronous)**

Code execution **pauses** until the operation completes.

Example (blocking):

```js
const fs = require("fs");

const data = fs.readFileSync("file.txt", "utf-8");  
console.log(data);  
console.log("This runs AFTER file read");
```

Flow:

1. Reads file
2. Waits
3. Only then prints second line

During the wait → **thread is blocked**.

---

### **Non-Blocking (Asynchronous)**

Execution does **not wait** for the operation to complete.

```js
const fs = require("fs");

fs.readFile("file.txt", "utf-8", (err, data) => {
  console.log(data);
});

console.log("This runs IMMEDIATELY");
```

Flow:

1. Starts file read
2. Moves ahead immediately
3. Prints "This runs immediately"
4. Later, prints file content when ready

This is the core of Node.js efficiency.

---

## **Why Non-Blocking Is Important**

### **1. High Concurrency**

Node handles **thousands of requests** because it never waits.

### **2. Low Resource Usage**

No thread per request, no heavy memory.

### **3. Fast Response Times**

Small tasks finish instantly while long operations work in background.

---

## **Where Non-Blocking Shows Its Power**

Node.js is ideal for:

* Chat applications
* APIs
* Notification systems
* Streaming servers
* Realtime dashboards
* High traffic microservices

---

## **Internal Mechanism: How Node Achieves Non-Blocking**

Non-blocking I/O works using:

### **Event Loop (Main Thread)**

Schedules tasks.

### **libuv Thread Pool**

Handles expensive operations:

* fs read/write
* crypto hashing
* DNS lookup

### **Callback Queue**

When result is ready → callback goes here.

### **Event Loop Executes Callback**

Non-blocking flow is complete.

---

## **Simple Analogy**

Blocking = You stand at the microwave waiting for food.
Non-blocking = You put food in, and do other work until the microwave beeps.

Node.js = second approach.

---

## **Short Interview Answer**

Non-blocking means Node.js never waits for I/O operations to finish. Instead, it initiates the operation, registers a callback, and continues executing other code. When the operation completes, the Event Loop triggers the callback. This allows Node.js to handle many concurrent operations efficiently using a single thread.

---

## **Summary Table**

| Mode         | Meaning                    | Thread Behaviour | Best For                        |
| ------------ | -------------------------- | ---------------- | ------------------------------- |
| Blocking     | Waits until task completes | Thread stops     | CPU-heavy tasks                 |
| Non-blocking | Does not wait              | Thread continues | I/O-heavy tasks, real-time apps |

---

# **7. How do you update Node.js to the latest version?**

## **Concept**

Updating Node.js depends on your operating system and the tools you use.
There are **four common ways** to update Node.js:

1. Using **Node Version Manager (NVM)** → best & recommended
2. Using **Official Installer** from nodejs.org
3. Using **Package Managers** (apt, brew, choco)
4. Using **n** (Node version manager for Linux/Mac)

The **recommended approach is NVM** because it allows switching between multiple Node.js versions easily.

---

# **Method 1: Update Node.js Using NVM (Recommended)**

### **Check installed versions**

```bash
node -v
nvm ls
```

### **Install latest Node.js version**

```bash
nvm install node
```

This installs the latest stable version.

### **Use a specific version**

```bash
nvm use 20
```

### **Set default Node version**

```bash
nvm alias default 20
```

**Why NVM?**

* multiple Node.js versions
* seamless switching
* no breaking global tools

---

# **Method 2: Official Installer (Windows/macOS)**

Visit:

```
https://nodejs.org
```

Download:

* LTS (recommended for production)
* Current (latest features)

Install it → Node is updated.

---

# **Method 3: Using Package Managers**

### **macOS (Homebrew)**

```bash
brew update
brew upgrade node
```

### **Ubuntu/Linux (APT)**

```bash
sudo apt update
sudo apt install nodejs npm
```

Or install latest via NodeSource:

```bash
curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
sudo apt-get install -y nodejs
```

### **Windows (Chocolatey)**

```bash
choco upgrade nodejs
```

---

# **Method 4: Using “n” (Node version manager)**

Install `n` globally:

```bash
npm install -g n
```

Install latest stable version:

```bash
sudo n stable
```

Install latest version:

```bash
sudo n latest
```

List versions:

```bash
n ls
```

---

# **Short Interview Answer**

Node.js can be updated using multiple methods. The recommended approach is using NVM, which allows installing and switching between multiple Node versions easily. You can also update Node using the official installer from nodejs.org, package managers like Homebrew or apt, or via the “n” version manager.

---

# **Summary Table**

| Method              | Best For                      | Command / Usage          |
| ------------------- | ----------------------------- | ------------------------ |
| NVM                 | Developers switching versions | `nvm install node`       |
| Official Installer  | Beginners                     | Download from nodejs.org |
| Package Manager     | System-wide updates           | `brew upgrade node`      |
| n (version manager) | Linux/macOS                   | `sudo n stable`          |

---

# **8. What is “npm” and what is it used for?**

## **Concept**

**npm (Node Package Manager)** is the default package manager for Node.js.
It is used to:

1. **Install packages (libraries)**
2. **Manage project dependencies**
3. **Publish open-source packages**
4. **Run scripts for building/testing applications**

npm is installed automatically when you install Node.js.

---

## **Why npm Exists**

Modern development requires:

* code reusability
* dependency management
* versioning
* sharing open-source modules

npm solves all of these by providing the world’s largest software ecosystem:
**Over 2 million packages**.

---

## **What npm Includes**

npm has two things:

### **1. Command Line Tool (CLI)**

Commands like:

* `npm install`
* `npm update`
* `npm uninstall`
* `npm run`

### **2. Online Registry**

A database of open-source packages published by developers.

Example packages:

* express
* mongoose
* lodash
* react
* axios

---

## **Common npm Commands (Most Asked in Interviews)**

### **Install package locally**

```bash
npm install express
```

### **Install package globally**

```bash
npm install -g nodemon
```

### **Install specific version**

```bash
npm install express@4.18.0
```

### **Remove package**

```bash
npm uninstall express
```

### **See outdated packages**

```bash
npm outdated
```

### **Update all packages**

```bash
npm update
```

### **Initialize new Node.js project**

```bash
npm init -y
```

---

## **Using npm Scripts**

package.json example:

```json
{
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest"
  }
}
```

Run script:

```bash
npm run dev
```

---

## **Behind the scenes: How npm manages dependencies**

When you install packages:

1. package.json → lists your dependencies
2. package-lock.json → locks exact versions
3. node_modules/ → actual code of packages

npm ensures consistency across all environments.

---

## **Short Interview Answer**

npm is the default package manager for Node.js. It is used to install, update, remove, and manage project dependencies, as well as publish and share packages. It also provides the world's largest package registry and supports running project scripts.

---

## **Summary Table**

| Feature               | Explanation                              |
| --------------------- | ---------------------------------------- |
| Package Registry      | Online database of Node.js packages      |
| CLI Tool              | Used for installing/managing libraries   |
| Dependency Management | Handles versions, installations, updates |
| Scripts               | Automates tasks like start, test, build  |

---

If ready, say **"next"** to continue with:

**Q9. How do you manage packages in a Node.js project?**

# **9. How do you manage packages in a Node.js project?**

## **Concept**

Package management in Node.js revolves around:

1. **npm or yarn** → tools used to install/manage packages
2. **package.json** → defines project dependencies
3. **package-lock.json** → locks exact versions
4. **node_modules/** → stores installed packages

Managing packages means:

* adding dependencies
* removing dependencies
* updating versions
* locking versions
* distinguishing between dev vs production dependencies
* ensuring reproducible installs

---

## **Key Elements of Package Management**

### **1. package.json**

Stores:

* project meta info
* dependencies
* scripts
* version constraints

Example:

```json
{
  "name": "my-app",
  "dependencies": {
    "express": "^4.18.2"
  },
  "devDependencies": {
    "nodemon": "^3.0.0"
  }
}
```

---

### **2. package-lock.json**

Locks **exact versions** installed to maintain consistency across environments.

If package.json says:

```
express: ^4.18.2
```

package-lock.json records:

```
express: 4.18.2
```

This ensures:

* same version on all machines
* reproducible builds

---

### **3. node_modules Folder**

Contains all installed dependencies.
Automatically created by npm.

---

# **How Packages Are Managed (Commands)**

## **1. Installing a Package**

### **Local Dependency (saved under dependencies)**

```bash
npm install express
```

package.json → adds under `dependencies`.

### **Dev Dependency**

Used only during development

```bash
npm install nodemon --save-dev
```

or

```bash
npm i nodemon -D
```

Saved under:

```json
"devDependencies": {
  "nodemon": "3.0.0"
}
```

---

## **2. Installing All Dependencies**

If someone shares their project:

```bash
npm install
```

Reads package.json → installs everything into node_modules.

---

## **3. Updating Packages**

Check outdated:

```bash
npm outdated
```

Update all minor versions:

```bash
npm update
```

Update to a specific version:

```bash
npm install express@5.0.0
```

---

## **4. Removing Packages**

```bash
npm uninstall express
```

Removes:

* from node_modules
* from package.json

---

## **5. Installing Global Packages**

Used for CLI tools (nodemon, pm2, typescript):

```bash
npm install -g nodemon
```

---

## **6. Managing Package Versions**

### **Caret (^)**

```json
"express": "^4.18.0"
```

Allows minor & patch updates.

### **Tilde (~)**

```json
"express": "~4.18.0"
```

Allows only patch updates.

### **Exact version**

```json
"express": "4.18.0"
```

---

## **7. Locking Dependencies for Production**

Use:

```bash
npm ci
```

This installs packages strictly based on `package-lock.json` and is used in CI/CD pipelines.

---

# **Short Interview Answer**

Packages in a Node.js project are managed using npm or yarn. Dependencies are listed in package.json, locked using package-lock.json, and installed into node_modules. You manage packages by installing, updating, and removing them via npm commands, and by distinguishing between production dependencies and dev dependencies.

---

# **Summary Table**

| Action                 | Command                 | Purpose                          |
| ---------------------- | ----------------------- | -------------------------------- |
| Install dependency     | `npm install express`   | Adds to project                  |
| Install dev dependency | `npm i nodemon -D`      | Used only in development         |
| Remove package         | `npm uninstall express` | Cleanup                          |
| Update package         | `npm update`            | Installs newer versions          |
| Install all deps       | `npm install`           | Builds node_modules              |
| Lock installs          | `npm ci`                | Strict reproducible installation |

---

# **10. What is a package.json file?**

## **Concept**

`package.json` is the **heart of every Node.js project**.
It is a JSON file that:

1. Stores your project metadata
2. Stores dependencies
3. Defines npm scripts
4. Helps npm manage versions
5. Makes the project portable and shareable

It is automatically created using:

```bash
npm init
```

or

```bash
npm init -y
```

---

# **Why package.json Exists**

Without package.json, a project would not know:

* which libraries it needs
* which versions to install
* how to run the app
* what commands/scripts exist
* what environment it expects

Every Node.js project relies on it.

---

# **Key Sections in package.json**

Below is the most common structure:

```json
{
  "name": "my-node-app",
  "version": "1.0.0",
  "description": "A sample Node project",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest"
  },
  "dependencies": {
    "express": "^4.18.2"
  },
  "devDependencies": {
    "nodemon": "^3.0.0"
  },
  "license": "MIT"
}
```

---

# **Important Fields Explained**

### **1. name**

Project name on npm (lowercase only).

### **2. version**

Project version (must follow semver).

### **3. description**

Short description of project.

### **4. main**

Entry point of your app.

### **5. scripts**

Defines custom commands.

Example:

```bash
npm run dev
```

### **6. dependencies**

Packages required in production.

Example:

```json
"express": "^4.18.2"
```

### **7. devDependencies**

Packages needed only for development.

Example:

```json
"nodemon": "^3.0.0"
```

### **8. license**

Defines legal usage of the project.

---

# **How package.json Helps in Development**

### **1. Reproducible Projects**

Anyone can install all dependencies using:

```bash
npm install
```

### **2. Centralized Command System**

All project commands stored under `scripts`.

### **3. Automatic Versioning**

Helps maintain consistent package versions.

### **4. Project Documentation**

Name, version, author, repo, issues link, etc.

---

# **Short Interview Answer**

`package.json` is a configuration file that contains metadata about a Node.js project, including its dependencies, scripts, version, and entry point. It allows npm to install, update, manage, and execute packages required by the project, and ensures the project is portable and maintainable.

---

# **Summary Table**

| Field           | Purpose                     |
| --------------- | --------------------------- |
| name            | Identifies project          |
| version         | Follows semantic versioning |
| scripts         | Defines runnable commands   |
| dependencies    | Runtime libraries           |
| devDependencies | Development-only libraries  |
| main            | Entry file of the project   |

---

