# Topic 26 Node.js Event Loop (Deep Understanding)

---

### **Concept**

**What is the Event Loop?**

* The **Event Loop** is the core part of Node.js responsible for handling **asynchronous** operations.
* Node.js is **single-threaded**, but still handles many concurrent tasks because of its **event-driven, non-blocking** architecture.
* Event Loop allows Node.js to perform tasks like:

  * File System operations (read/write)
  * Network/HTTP requests
  * Timers (`setTimeout`, `setInterval`)
  * Database queries

All without blocking the main thread.

---

### **Why Event Loop?**

| Need                                      | Benefit                                  |
| ----------------------------------------- | ---------------------------------------- |
| Handle thousands of concurrent requests   | Non-blocking I/O                         |
| Prevent server freeze on slow operations  | Heavy tasks are offloaded to thread pool |
| Efficient for APIs, Chats, Real-time apps | Always responsive                        |
| Avoid multi-thread complexity             | Single-threaded development              |

---

### **How Event Loop Works (High-Level)**

1. **Call Stack** runs top-level code.
2. Async tasks are pushed to:

   * **Microtask queue** (Promises, process.nextTick)
   * **Callback queue** (Timers, IO, network events)
3. Event Loop checks:

   * If Call Stack is empty → takes tasks from queues.
4. Repeats forever.

---

### **Event Loop Phases**

| Phase                 | Description                                          |
| --------------------- | ---------------------------------------------------- |
| **Timers**            | Executes callbacks from `setTimeout` / `setInterval` |
| **Pending callbacks** | System-level callbacks                               |
| **Idle/Prepare**      | Internal use                                         |
| **Poll**              | Retrieves new I/O events                             |
| **Check**             | Executes `setImmediate()` callbacks                  |
| **Close callbacks**   | Cleanup events like `socket.on('close')`             |

---

### **Microtask vs Macrotask Priority**

**Microtasks run before next Event Loop phase.**

| Microtask Queue                     | Macrotask Queue       |
| ----------------------------------- | --------------------- |
| Promises (`then`, `catch`)          | Timers (`setTimeout`) |
| process.nextTick (highest priority) | setInterval           |
| queueMicrotask()                    | setImmediate          |

Execution order:

```
process.nextTick  →  Promise callbacks  →  next Event Loop Phase
```

---

### **Code Example 1: Execution Order**

**File:** `eventloop1.js`

```js
console.log("Start");

setTimeout(() => {
  console.log("Timeout");
}, 0);

Promise.resolve().then(() => {
  console.log("Promise");
});

console.log("End");
```

**Run:**

```bash
node eventloop1.js
```

**Output:**

```
Start
End
Promise
Timeout
```

Reason: Promise callback (microtask) executes before timeout (macrotask).

---

### **Code Example 2: nextTick vs Promise**

**File:** `eventloop2.js`

```js
console.log("Start");

process.nextTick(() => console.log("nextTick"));
Promise.resolve().then(() => console.log("Promise"));

console.log("End");
```

**Output:**

```
Start
End
nextTick
Promise
```

nextTick executes before Promise even though both are microtasks.

---

### **Code Example 3: setImmediate vs setTimeout**

**File:** `eventloop3.js`

```js
setTimeout(() => console.log("Timeout"), 0);
setImmediate(() => console.log("Immediate"));
```

Output order is not guaranteed, but *typically*:

```
Timeout
Immediate
```

because timeout goes to timer phase before check phase.
However, in some cases the reverse happens, so do not rely on this order.

---

### **Event Loop with File System (Thread Pool Offloading)**

**File:** `eventloop4.js`

```js
const fs = require("fs");

console.log("Start");

fs.readFile("sample.txt", () => {
  console.log("File Read");
});

console.log("End");
```

**Output:**

```
Start
End
File Read
```

File operation goes to **libuv thread pool** and callback returns later.

---

### **Event Loop Flow Summary**

```
Top-level code → Microtasks → Event Loop Phases:
Timers → Pending Callbacks → Poll → Check → Close
```

---

### **Mini Project: Event Loop Analyzer**

**Goal:** Visualize execution order of tasks.

**File:** `eventloop-demo.js`

```js
console.log("1: Start");

setTimeout(() => console.log("2: Timeout"), 0);
setImmediate(() => console.log("3: Immediate"));

Promise.resolve().then(() => console.log("4: Promise"));

process.nextTick(() => console.log("5: nextTick"));

console.log("6: End");
```

Run multiple times and observe ordering.

Expected sequence:

```
1: Start
6: End
5: nextTick
4: Promise
(2/3 unpredictable but usually Timeout then Immediate)
```

---

### **Use Cases of Event Loop**

| Application Area                 | Reason                     |
| -------------------------------- | -------------------------- |
| REST APIs                        | Parallel request handling  |
| Real-time systems (chat, gaming) | Event-driven model         |
| Streams, sockets                 | Non-blocking I/O           |
| Queues, schedulers               | Timer + microtask handling |

---

### **Dependencies**

None. Event Loop is built into Node.js core (powered by V8 + libuv).

---

### **Notes**

* Use async code correctly to avoid blocking Event Loop.
* Avoid CPU-heavy tasks in Event Loop. Offload using:

  * Worker Threads
  * Child Processes
* Microtasks can block Event Loop if used excessively.
* `process.nextTick` should be used carefully to avoid starvation.

---

### **Quick Summary Table**

| Concept                     | Priority    |
| --------------------------- | ----------- |
| `process.nextTick()`        | Highest     |
| Promise callbacks           | Next        |
| `setTimeout`, `setInterval` | Timer Phase |
| `setImmediate()`            | Check Phase |
| File system, network I/O    | Poll Phase  |

---
